<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://example.org/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://example.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://example.org/20230210122139-dynamic_programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230210122139-dynamic_programming/</guid>
      <description>Dynamic Programming It&amp;#39;s an advanced Algorithm In computer science, dynamic programming is an algorithmic method for solving optimization problems. The concept was introduced in the early 1950s by Richard Bellman. At the time, the term « programming » means planning and scheduling&#xA;The most used techniques for dynamic programming are:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230318125421-binary_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230318125421-binary_search/</guid>
      <description>Binary Search INFO Binary Search called &amp;#34;Recherche Dichotomique&amp;#34; in French is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half.&#xA;APPROACH Find the Exact Value class Solution { public: int search(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int leftPtr = 0; int rightPtr = nums.size() - 1; while (leftPtr &amp;lt;= rightPtr) { int m = (leftPtr + rightPtr) / 2; if (nums[m] == target) return m; else if (nums[m] &amp;lt; target) leftPtr = m + 1; else rightPtr = m - 1; } return -1; } }; Find Upper bound class Solution { public: int search(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int leftPtr = 0; int rightPtr = nums.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230318190022-two_pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230318190022-two_pointers/</guid>
      <description>Two Pointers INFO The two pointers is a searching algorithm if you want at the same time:&#xA;Search two elements in an array Search and do something in an array Keep in mind an index when moving another Ect… </description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230321105437-bitwise_operation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230321105437-bitwise_operation/</guid>
      <description>Bitwise Operation Logically, a bit-to-bit operation is a calculation manipulating the data directly at the level of the bits, according to a Boolean arithmetic&#xA;Use in Programming Advanced to be blazingly fast&#xA;OPERATORS </description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230323194445-problem_solving/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230323194445-problem_solving/</guid>
      <description>Problem Solving Problem solving is the process of identifying and then implementing a solution to a problem.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230323194502-subrectanglequeries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230323194502-subrectanglequeries/</guid>
      <description>SubRectangleQueries PROBLEM Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:&#xA;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).&#xA;getValue(int row, int col) Returns the current value of the coordinate (row,col) from the rectangle.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230324135547-square_of_a_sorted_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230324135547-square_of_a_sorted_array/</guid>
      <description>Square Of A Sorted Array PROBLEM Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order&#xA;Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?&#xA;Example1 *Input*: nums = [-4,-1,0,3,10] *Output*: [0,1,9,16,100] *Explanation*: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2 *Input*: nums = [-7,-3,2,3,11] *Output*: [4,9,9,49,121] SOLVING We will use Two Pointers technique.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230324205136-rotate_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230324205136-rotate_array/</guid>
      <description>Rotate Array PROBLEM Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.&#xA;Example 1 *Input*: nums = [1,2,3,4,5,6,7], k = 3 *Output*: [5,6,7,1,2,3,4] *Explanation*: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2 *Input*: nums = [-1,-100,3,99], k = 2 *Output*: [3,99,-1,-100] *Explanation*: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] SOLVING We&amp;#39;ll use the Two Pointers method</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230325002052-search_insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230325002052-search_insert/</guid>
      <description>Search Insert PROBLEM In an sorted array [1, 3, 5, 6, 8], you want to know the index to insert your target, 5 In an sorted array [1, 3, 5, 6, 8], you want to know the index to insert your target, 2 SOLVING Use of Binary Search method.&#xA;This code will return the index 2, where the target already is This code will return the index 1 where the target should be Steps Place Left Pointer at 0 and Right Pointer to the last element Until Left Element is inferior to Right Element:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230325150824-move_zeroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230325150824-move_zeroes/</guid>
      <description>Move Zeroes PROBLEM Given an integer array nums, move all 0&amp;#39;s to the end of it while maintaining the relative order of the non-zero elements.&#xA;Note that you must do this in-place without making a copy of the array.&#xA;Example1 *Input*: nums = [0,1,0,3,12] *Output*: [1,3,12,0,0] Example2 *Input*: nums = [0] *Output*: [0] Constraints 1&amp;lt;=nums.length&amp;lt;=104 -231&amp;lt;=nums[i]&amp;lt;=231-1 Follow up: Could you minimize the total number of operations done?&#xA;SOLVING We&amp;#39;ll use the Two Pointers method</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230325165639-two_sum_array_sorted/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230325165639-two_sum_array_sorted/</guid>
      <description>Two Sum || Array Sorted PROBLEM Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1&amp;lt;=index1&amp;lt;index2&amp;lt;=numbers.length.&#xA;Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.&#xA;The tests are generated such that there is exactly one solution.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230326152448-reverse_words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230326152448-reverse_words/</guid>
      <description>Reverse Words PROBLEM Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&#xA;Example1 *Input*: s = &amp;#34;Let&amp;#39;s take LeetCode contest&amp;#34; *Output*: &amp;#34;s&amp;#39;teL ekat edoCteeL tsetnoc&amp;#34; Example2 *Input*: s = &amp;#34;God Ding&amp;#34; *Output*: &amp;#34;diG gniD&amp;#34; Constraints 1&amp;lt;=s.length&amp;lt;=5*104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230327124138-minimum_path_sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230327124138-minimum_path_sum/</guid>
      <description>Minimum Path Sum PROBLEM Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.&#xA;Note: You can only move either down or right at any point in time.&#xA;Example ---&#xA;---&#xA;---&#xA;---&#xA;*Input*: grid = [[1,3,1],[1,5,1],[4,2,1]] *Output*: 7 Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230328161837-longest_substring_without_repeating_characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230328161837-longest_substring_without_repeating_characters/</guid>
      <description>Longest Substring Without Repeating Characters PROBLEM Given a string s, find the length of the longest substring without repeating characters.&#xA;Example1 *Input*: s = &amp;#34;abcabcbb&amp;#34; *Output*: 3 Explanation: The answer is &amp;#34;abc&amp;#34;, with the length of 3. Example2 *Input*: s = &amp;#34;bbbbb&amp;#34; *Output*: 1 Explanation: The answer is &amp;#34;b&amp;#34;, with the length of 1. Example3 *Input*: s = &amp;#34;pwwkew&amp;#34; *Output*: 3 Explanation: The answer is &amp;#34;wke&amp;#34;, with the length of 3.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230328173445-check_inclusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230328173445-check_inclusion/</guid>
      <description>Check Inclusion PROBLEM Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.&#xA;In other words, return true if one of s1&amp;#39;s permutations is the substring of s2.&#xA;Example1 *Input*: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidbaooo&amp;#34; *Output*: true Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;). Example2 =Input=: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidboaoo&amp;#34; =Output=: false SOLVING Steps Create two vectors of size 26 filled by some 0 for the two string Fill the first vector with the string s1:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230328185255-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230328185255-backtracking/</guid>
      <description>Backtracking INFO It&amp;#39;s an Algorithm to permute string. Usefull to find all the possible permutations&#xA;EXAMPLE Steps Create a function which take the string, the first index and the last index:&#xA;If start and end index are the same, end of the algorithm (print or return depends on what you wants) Otherwise, loop on each index between start and end:&#xA;Swap string at index start and string at index i of loop Call the function with as first index the first index + 1 Swap again string at index start and string at index i of loop Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; void backtrack(std::string &amp;amp;s, int idx, int N) { if (idx == N) std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl; else { for (int i = idx; i &amp;lt;= N; i++) { std::swap(s[idx], s[i]); backtrack(s, idx + 1, N); // Reset std::swap(s[idx], s[i]); } } } int main(int ac, char *av[]) { std::string s = &amp;#34;ABC&amp;#34;; int n = s.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230328225116-minimum_time_to_type_using_special_typewritter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230328225116-minimum_time_to_type_using_special_typewritter/</guid>
      <description>Minimum Time To Type Using Special Typewritter PROBLEM There is a special typewriter with lowercase English letters &amp;#39;a&amp;#39; to &amp;#39;z&amp;#39; arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character &amp;#39;a&amp;#39;.&#xA;Each second, you may perform one of the following operations:&#xA;Move the Pointer one character counterclockwise or clockwise Type the character the pointer is currently only Given a string word, return the minimum number of seconds to type out the characters in word.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230329193135-depth_first_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230329193135-depth_first_search/</guid>
      <description>Depth-first Search INFO The deep path algorithm is a tree path algorithm, and more generally a graph path. He naturally describes himself in a recursive way. Its simplest application is to determine if there is a path from one summit to another</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230329194332-max_area_of_island_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230329194332-max_area_of_island_array/</guid>
      <description>Max Area Of Island Array PROBLEM You are given an m x n binary matrix grid. An island is a group of 1&amp;#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.&#xA;The area of an island is the number of cells with a value 1 in the island.&#xA;Return the maximum area of an island in grid. If there is no island, return 0.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230330131636-merge_two_binary_trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230330131636-merge_two_binary_trees/</guid>
      <description>Merge Two Binary Trees PROBLEM You are given two binary trees root1 and root2.&#xA;Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230330142115-breadth_first_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230330142115-breadth_first_search/</guid>
      <description>Breadth-first Search INFO The width path algorithm allows the path of a graph or a tree as follows: we start by exploring a source node, then its successors, then the unexplored successors of successors, etc</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230330154600-populating_next_right_pointers_in_each_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230330154600-populating_next_right_pointers_in_each_node/</guid>
      <description>Populating Next Right Pointers In Each Node PROBLEM You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:&#xA;struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230331120200-matrix_distance_nearest_zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230331120200-matrix_distance_nearest_zero/</guid>
      <description>Matrix Distance Nearest 0 PROBLEM Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.&#xA;The distance between two adjacent cells is 1.&#xA;Example1 ---&#xA;---&#xA;---&#xA;---&#xA;*Input*: mat = [[0,0,0],[0,1,0],[0,0,0]] *Output*: [[0,0,0],[0,1,0],[0,0,0]] Example2 ---&#xA;---&#xA;---&#xA;---&#xA;*Input*: mat = [[0,0,0],[0,1,0],[1,1,1]] *Output*: [[0,0,0],[0,1,0],[1,2,1]] SOLVING we&amp;#39;ll use Breadth-first Search method&#xA;Steps Create matrix result with the same size filled by 0 Create a queue Parcor the list if there is a 1 next to a 0 :</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230331192627-rotting_oranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230331192627-rotting_oranges/</guid>
      <description>Rotting Oranges PROBLEM You are given an m x n grid where each cell can have one of three values:&#xA;0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.&#xA;Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230401154745-reverse_linked_list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230401154745-reverse_linked_list/</guid>
      <description>Reverse Linked List PROBLEM Given the head of a singly linked list, reverse the list, and return the reversed list.&#xA;Example1 *Input*: head = [1,2,3,4,5] *Output*: [5,4,3,2,1] Example2 *Input*: head = [1,2] *Output*: [2,1] Example3 *Input*: head = [] *Output*: [] SOLVING Steps Create prevNode and nextNode to solve this problem nextNode equal head next N head next equal prevNode H prevNode equal head P head equal nextNode return prevNode Example1 P H N ↓ ↓ ↓ NULL [1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3 &amp;lt;- 4 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3 &amp;lt;- 4 &amp;lt;- 5] NULL] Return prevNode Code class Solution { public: ListNode *reverseList(ListNode *head) { ListNode *nextNode = nullptr; ListNode *prevNode = nullptr; while (head) { nextNode = head-&amp;gt;next; head-&amp;gt;next = prevNode; prevNode = head; head = nextNode; } return prevNode; } }; </description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230403130528-permutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230403130528-permutation/</guid>
      <description>Permutation PROBLEM Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.&#xA;Example1 *Input*: nums = [1,2,3] *Output*: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example2 *Input*: nums = [0,1] *Output*: [[0,1],[1,0]] Example3 *Input*: nums = [1] *Output*: [ [1] ] Constraints 1&amp;lt;=nums.length&amp;lt;=6 -10&amp;lt;=nums[i]&amp;lt;=10 All the integers of nums are unique. SOLVING we&amp;#39;ll use Backtracking method&#xA;Steps Backtracking method:&#xA;push in result and return if current index equal size for each index between current index and size:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230403182310-letter_case_permutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230403182310-letter_case_permutation/</guid>
      <description>Letter Case Permutation PROBLEM Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.&#xA;Return a list of all possible strings we could create. Return the output in any order.&#xA;Example1 *Input*: s = &amp;#34;a1b2&amp;#34; *Output*: [&amp;#34;a1b2&amp;#34;,&amp;#34;a1B2&amp;#34;,&amp;#34;A1b2&amp;#34;,&amp;#34;A1B2&amp;#34;] Example2 *Input*: s = &amp;#34;3z4&amp;#34; *Output*: [&amp;#34;3z4&amp;#34;,&amp;#34;3Z4&amp;#34;] Constraints s consits of lowercase English letters, uppercase English letters and digits SOLVING we&amp;#39;ll use Backtracking method.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230403182833-climbing_stairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230403182833-climbing_stairs/</guid>
      <description>Climbing Stairs PROBLEM You are climbing a staircase. It takes n steps to reach the top.&#xA;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&#xA;Example1 *Input*: n = 2 *Output*: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example2 *Input*: n = 3 *Output*: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230404141041-is_power_of_two/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230404141041-is_power_of_two/</guid>
      <description>Is Power Of Two PROBLEM Given an integer n, return true if it is a power of two. Otherwise, return false.&#xA;An integer n is a power of two, if there exists an integer x such that n = 2x.=&#xA;Example1 *Input*: n = 1 *Output*: true Explanation: 20 = 1 Example2 *Input*: n = 16 *Output*: true Explanation: 24 = 16 Example3 *Input*: n = 3 *Output*: false SOLVING we&amp;#39;ll use Bit manipulation method.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230405191637-house_robber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230405191637-house_robber/</guid>
      <description>House Robber PROBLEM You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&#xA;Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230405204138-reverse_bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230405204138-reverse_bits/</guid>
      <description>Reverse Bits PROBLEM Reverse bits of a given 32 bits unsigned integer.&#xA;SOLVING We&amp;#39;ll use Bit Manipulation method&#xA;Steps Create a uint32_t result we&amp;#39;ll return as the answer Repeat 32 time or the longer of your bit&#xA;result equal to result or (| or bit operation) on the result of n and (&amp;amp; and bit operation) 1 to get the first bit Example Example with 6bit (32 is tooooo long) 011101</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230409130224-minimum_penalty_for_a_shop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230409130224-minimum_penalty_for_a_shop/</guid>
      <description>Minimum Penalty for a Shop PROBLEM You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters &amp;#39;N&amp;#39; and &amp;#39;Y&amp;#39;:&#xA;if the ith character is &amp;#39;Y&amp;#39; , it means that customers come at the ith hour whereas &amp;#39;N&amp;#39; indicates that no customers come at the ith hour. If the shop closes at the jth hour (0&amp;lt;=j&amp;lt;=n), the penalty is calculated as follows:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230410164240-valid_parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230410164240-valid_parentheses/</guid>
      <description>Valid Parentheses PROBLEM Given a string s containing just the characters &amp;#39;(&amp;#39; , &amp;#39;)&amp;#39; , &amp;#39;{&amp;#39; , &amp;#39;}&amp;#39; , &amp;#39;[&amp;#39; and &amp;#39;]&amp;#39;, determine if the input string is valid.&#xA;An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example1 *Input*: s = &amp;#34;()&amp;#34; *Output*: true Example2 *Input*: s = &amp;#34;([]){}&amp;#34; *Output*: true Example3 *Input*: s = &amp;#34;(]&amp;#34; *Output*: false SOLVING Steps Create a Stack Browse the string:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230413152606-palindrome_number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230413152606-palindrome_number/</guid>
      <description>Palindrome Number PROBLEM Given an integer x, return true if x is a palindrome, and false otherwise.&#xA;Example1 *Input*: x = 121 *Output*: true *Explanation*: 121 reads as 121 from left to right and from right to left. Example2 *Input*: x = -121 *Output*: false *Explanation*: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example3 *Input*: x = 10 *Output*: false *Explanation*: Reads 01 from right to left.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230416160653-regex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230416160653-regex/</guid>
      <description>Regex REGULAR EXPRESSION (REGEX) In Computer Science a regular expression or rational expression or normal expression or pattern is a string which describes, according to a precise syntax, a set of possible character strings. Regular expressions are also called regex.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230416164058-valid_phone_numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230416164058-valid_phone_numbers/</guid>
      <description>Valid Phone Numbers PROBLEM Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.&#xA;You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)&#xA;You may also assume each line in the text file must not contain leading or trailing white spaces.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230416204354-group_anagrams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230416204354-group_anagrams/</guid>
      <description>Group Anagrams PROBLEM Given an array of strings strs, group the anagrams together. You can return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example1 *Input*: strs = [&amp;#34;eat&amp;#34;,&amp;#34;tea&amp;#34;,&amp;#34;tan&amp;#34;,&amp;#34;ate&amp;#34;,&amp;#34;nat&amp;#34;,&amp;#34;bat&amp;#34;] *Output*: [[&amp;#34;bat&amp;#34;],[&amp;#34;nat&amp;#34;,&amp;#34;tan&amp;#34;],[&amp;#34;ate&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;tea&amp;#34;]] Example2 *Input*: strs = [&amp;#34;&amp;#34;] *Output*: [ [&amp;#34;&amp;#34;] ] Example3 *Input*: strs = [&amp;#34;a&amp;#34;] *Output*: [ [&amp;#34;a&amp;#34;] ] SOLVING We&amp;#39;ll use Hash and Array to solve this problem</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230430120652-search_a_2d_matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230430120652-search_a_2d_matrix/</guid>
      <description>Search a 2D Matrix PROBLEM You are given an m x n integer matrix matrix with the following two properties:&#xA;Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.&#xA;You must write a solution in O(log(m * n)) time complexity.&#xA;Example1 *Input*: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 *Output*: true Example2 *Input*: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 *Output*: false SOLVING we&amp;#39;ll use Binary Search exact value to solve this problem</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230430154252-remove_duplicates_from_sorted_list_ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230430154252-remove_duplicates_from_sorted_list_ii/</guid>
      <description>Remove Duplicates from Sorted List II PROBLEM Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.&#xA;Example1 *Input*: head = [1,2,3,3,4,4,5] *Output*: [1,2,5] SOLVING We&amp;#39;ll use Two Pointers method to solve this problem&#xA;Steps Create a Node dummy with val (0 for this example) pointing to head Create a Node prev equal to dummy Parcor the Linked List:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230430213801-interval_list_intersections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230430213801-interval_list_intersections/</guid>
      <description>Interval List Intersections PROBLEM You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order.&#xA;Return the intersection of these two interval lists.&#xA;A closed interval [a, b] (with a&amp;lt;=b) denotes the set of real numbers x with a&amp;lt;=x&amp;lt;=b.&#xA;The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230514103427-find_all_anagrams_in_a_string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230514103427-find_all_anagrams_in_a_string/</guid>
      <description>Find All Anagrams in a String PROBLEM Given two strings s and p, return an array of all the start indices of p&amp;#39;s anagrams in s. You may return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1 *Input*: s = &amp;#34;cbaebabacd&amp;#34;, p = &amp;#34;abc&amp;#34; *Output*: [0,6] *Explanation*: The substring with start index = 0 is &amp;#34;cba&amp;#34;, which is an anagram of &amp;#34;abc&amp;#34;.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230516164030-bucket_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230516164030-bucket_sort/</guid>
      <description>Bucket Sort BUCKET SORT Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm.&#xA;Pseudo Code function bucketSort(array, k) is buckets = new array of k empty lists M = 1 + the maximum key value in the array for i = 0 to length(array) do insert array[i] into buckets[floor(k × array[i] / M)] for i = 0 to k do nextSort(buckets[i]) return the concatenation of buckets[0], .</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230517211447-top_k_frequent_elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230517211447-top_k_frequent_elements/</guid>
      <description>Top K Frequent Elements PROBLEM Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&#xA;Example 1 *Input*: nums = [1,1,1,2,2,3], k = 2 *Output*: [1,2] Example 2 *Input*: nums = [1], k = 1 *Output*: [1] SOLVING We&amp;#39;ll use the Bucket Sort method.&#xA;Steps Create a Map to store the frequency of each letters, a Map buckets and the array for the result Iterate on the string use each letter as key for frequency and increase by one the value Fill the buckets by using the value of frequency as the key of buckets and add the key of frequency in the value of the bucket Iterate from the end of buckets:</description>
    </item>
    <item>
      <title></title>
      <link>https://example.org/20230528143513-product_of_array_except_self/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/20230528143513-product_of_array_except_self/</guid>
      <description>Product of Array Except Self PROBLEM Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&#xA;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&#xA;You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1 **Input**: nums = [1,2,3,4] **Output**: [24,12,8,6] Example 2 **Input**: nums = [-1,1,0,-3,3] **Output**: [0,0,9,0,0] SOLVING We are going to make to iteration.</description>
    </item>
    <item>
      <title>Backtracking</title>
      <link>https://example.org/posts/20230328185255-backtracking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230328185255-backtracking/</guid>
      <description>INFO It&amp;rsquo;s an Algorithm to permute string. Usefull to find all the possible permutations&#xA;EXAMPLE Steps Create a function which take the string, the first index and the last index: If start and end index are the same, end of the algorithm (print or return depends on what you wants) Otherwise, loop on each index between start and end: Swap string at index start and string at index i of loop Call the function with as first index the first index + 1 Swap again string at index start and string at index i of loop Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; void backtrack(std::string &amp;amp;s, int idx, int N) { if (idx == N) std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl; else { for (int i = idx; i &amp;lt;= N; i++) { std::swap(s[idx], s[i]); backtrack(s, idx + 1, N); // Reset std::swap(s[idx], s[i]); } } } int main(int ac, char *av[]) { std::string s = &amp;#34;ABC&amp;#34;; int n = s.</description>
    </item>
    <item>
      <title>Binary Search</title>
      <link>https://example.org/posts/20230318125421-binary_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230318125421-binary_search/</guid>
      <description>INFO Binary Search called &amp;ldquo;Recherche Dichotomique&amp;rdquo; in French is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half.&#xA;APPROACH Find the Exact Value class Solution { public: int search(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int leftPtr = 0; int rightPtr = nums.size() - 1; while (leftPtr &amp;lt;= rightPtr) { int m = (leftPtr + rightPtr) / 2; if (nums[m] == target) return m; else if (nums[m] &amp;lt; target) leftPtr = m + 1; else rightPtr = m - 1; } return -1; } }; Find Upper bound class Solution { public: int search(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int leftPtr = 0; int rightPtr = nums.</description>
    </item>
    <item>
      <title>Bitwise Operation</title>
      <link>https://example.org/posts/20230321105437-bitwise_operation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230321105437-bitwise_operation/</guid>
      <description>Logically, a bit-to-bit operation is a calculation manipulating the data directly at the level of the bits, according to a Boolean arithmetic&#xA;Use in Programming Advanced to be blazingly fast&#xA;OPERATORS </description>
    </item>
    <item>
      <title>Breadth-first Search</title>
      <link>https://example.org/posts/20230330142115-breadth_first_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230330142115-breadth_first_search/</guid>
      <description>INFO The width path algorithm allows the path of a graph or a tree as follows: we start by exploring a source node, then its successors, then the unexplored successors of successors, etc</description>
    </item>
    <item>
      <title>Bucket Sort</title>
      <link>https://example.org/posts/20230516164030-bucket_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230516164030-bucket_sort/</guid>
      <description>BUCKET SORT Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm.&#xA;Pseudo Code function bucketSort(array, k) is buckets = new array of k empty lists M = 1 + the maximum key value in the array for i = 0 to length(array) do insert array[i] into buckets[floor(k × array[i] / M)] for i = 0 to k do nextSort(buckets[i]) return the concatenation of buckets[0], .</description>
    </item>
    <item>
      <title>Check Inclusion</title>
      <link>https://example.org/posts/20230328173445-check_inclusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230328173445-check_inclusion/</guid>
      <description>PROBLEM Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.&#xA;In other words, return true if one of s1&amp;rsquo;s permutations is the substring of s2.&#xA;Example1 *Input*: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidbaooo&amp;#34; *Output*: true Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;). Example2 =Input=: s1 = &amp;#34;ab&amp;#34;, s2 = &amp;#34;eidboaoo&amp;#34; =Output=: false SOLVING Steps Create two vectors of size 26 filled by some 0 for the two string Fill the first vector with the string s1: For each char: Increase by one at position char - &#39;a&#39; (transform a-z into 0-26) Create index i and j to 0 Use j to parcor string s2 and increase by one the second vector at position s2[j] If j-i equal length of string s1 that means second vector has enough information to compare two vector for permutation If j-i inferior at length of string s1 that means second vector doesn&amp;rsquo;t has enough information to compare two vector for permutation, so only increase j Otherwise increase i and j and decrease s2[i] because not in the scoop of search anymore If previous compare didn&amp;rsquo;t work return false Code class Solution { private: bool areVectorsEqual(vector&amp;lt;int&amp;gt; a, vector&amp;lt;int&amp;gt; b) { for (int i = 0; i &amp;lt; 26; i++) { if (a[i] !</description>
    </item>
    <item>
      <title>Climbing Stairs</title>
      <link>https://example.org/posts/20230403182833-climbing_stairs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230403182833-climbing_stairs/</guid>
      <description>PROBLEM You are climbing a staircase. It takes n steps to reach the top.&#xA;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&#xA;Example1 *Input*: n = 2 *Output*: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example2 *Input*: n = 3 *Output*: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    <item>
      <title>Depth-first Search</title>
      <link>https://example.org/posts/20230329193135-depth_first_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230329193135-depth_first_search/</guid>
      <description>INFO The deep path algorithm is a tree path algorithm, and more generally a graph path. He naturally describes himself in a recursive way. Its simplest application is to determine if there is a path from one summit to another</description>
    </item>
    <item>
      <title>Dynamic Programming</title>
      <link>https://example.org/posts/20230210122139-dynamic_programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230210122139-dynamic_programming/</guid>
      <description>It&amp;rsquo;s an advanced Algorithm In computer science, dynamic programming is an algorithmic method for solving optimization problems. The concept was introduced in the early 1950s by Richard Bellman. At the time, the term « programming » means planning and scheduling&#xA;The most used techniques for dynamic programming are:</description>
    </item>
    <item>
      <title>Find All Anagrams in a String</title>
      <link>https://example.org/posts/20230514103427-find_all_anagrams_in_a_string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230514103427-find_all_anagrams_in_a_string/</guid>
      <description>PROBLEM Given two strings s and p, return an array of all the start indices of p&amp;rsquo;s anagrams in s. You may return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1 *Input*: s = &amp;#34;cbaebabacd&amp;#34;, p = &amp;#34;abc&amp;#34; *Output*: [0,6] *Explanation*: The substring with start index = 0 is &amp;#34;cba&amp;#34;, which is an anagram of &amp;#34;abc&amp;#34;.</description>
    </item>
    <item>
      <title>Group Anagrams</title>
      <link>https://example.org/posts/20230416204354-group_anagrams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230416204354-group_anagrams/</guid>
      <description>PROBLEM Given an array of strings strs, group the anagrams together. You can return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example1 *Input*: strs = [&amp;#34;eat&amp;#34;,&amp;#34;tea&amp;#34;,&amp;#34;tan&amp;#34;,&amp;#34;ate&amp;#34;,&amp;#34;nat&amp;#34;,&amp;#34;bat&amp;#34;] *Output*: [[&amp;#34;bat&amp;#34;],[&amp;#34;nat&amp;#34;,&amp;#34;tan&amp;#34;],[&amp;#34;ate&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;tea&amp;#34;]] Example2 *Input*: strs = [&amp;#34;&amp;#34;] *Output*: [ [&amp;#34;&amp;#34;] ] Example3 *Input*: strs = [&amp;#34;a&amp;#34;] *Output*: [ [&amp;#34;a&amp;#34;] ] SOLVING We&amp;rsquo;ll use Hash and Array to solve this problem</description>
    </item>
    <item>
      <title>House Robber</title>
      <link>https://example.org/posts/20230405191637-house_robber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230405191637-house_robber/</guid>
      <description>PROBLEM You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&#xA;Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    <item>
      <title>Interval List Intersections</title>
      <link>https://example.org/posts/20230430213801-interval_list_intersections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230430213801-interval_list_intersections/</guid>
      <description>PROBLEM You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order.&#xA;Return the intersection of these two interval lists.&#xA;A closed interval [a, b] (with a&amp;lt;=b) denotes the set of real numbers x with a&amp;lt;=x&amp;lt;=b.&#xA;The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval.</description>
    </item>
    <item>
      <title>Is Power Of Two</title>
      <link>https://example.org/posts/20230404141041-is_power_of_two/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230404141041-is_power_of_two/</guid>
      <description>PROBLEM Given an integer n, return true if it is a power of two. Otherwise, return false.&#xA;An integer n is a power of two, if there exists an integer x such that n = 2x.=&#xA;Example1 *Input*: n = 1 *Output*: true Explanation: 20 = 1 Example2 *Input*: n = 16 *Output*: true Explanation: 24 = 16 Example3 *Input*: n = 3 *Output*: false SOLVING we&amp;rsquo;ll use Bit manipulation method.</description>
    </item>
    <item>
      <title>Letter Case Permutation</title>
      <link>https://example.org/posts/20230403182310-letter_case_permutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230403182310-letter_case_permutation/</guid>
      <description>PROBLEM Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.&#xA;Return a list of all possible strings we could create. Return the output in any order.&#xA;Example1 *Input*: s = &amp;#34;a1b2&amp;#34; *Output*: [&amp;#34;a1b2&amp;#34;,&amp;#34;a1B2&amp;#34;,&amp;#34;A1b2&amp;#34;,&amp;#34;A1B2&amp;#34;] Example2 *Input*: s = &amp;#34;3z4&amp;#34; *Output*: [&amp;#34;3z4&amp;#34;,&amp;#34;3Z4&amp;#34;] Constraints s consits of lowercase English letters, uppercase English letters and digits SOLVING we&amp;rsquo;ll use Backtracking method.&#xA;Steps If the index equal to size push to the result the string Call once the method with the exact same string and just the index + 1 If the current element is an alpha change uppercase &amp;lt;&amp;ndash;&amp;gt; lowercase and call a second time the method Return the result Code class Solution { public: vector&amp;lt;string&amp;gt; letterCasePermutation(string s) { vector&amp;lt;string&amp;gt; result; backtrack(s, 0, s.</description>
    </item>
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://example.org/posts/20230328161837-longest_substring_without_repeating_characters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230328161837-longest_substring_without_repeating_characters/</guid>
      <description>PROBLEM Given a string s, find the length of the longest substring without repeating characters.&#xA;Example1 *Input*: s = &amp;#34;abcabcbb&amp;#34; *Output*: 3 Explanation: The answer is &amp;#34;abc&amp;#34;, with the length of 3. Example2 *Input*: s = &amp;#34;bbbbb&amp;#34; *Output*: 1 Explanation: The answer is &amp;#34;b&amp;#34;, with the length of 1. Example3 *Input*: s = &amp;#34;pwwkew&amp;#34; *Output*: 3 Explanation: The answer is &amp;#34;wke&amp;#34;, with the length of 3. Notice that the answer must be a substring, &amp;#34;pwke&amp;#34; is a subsequence and not a substring.</description>
    </item>
    <item>
      <title>Matrix Distance Nearest 0</title>
      <link>https://example.org/posts/20230331120200-matrix_distance_nearest_zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230331120200-matrix_distance_nearest_zero/</guid>
      <description>PROBLEM Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.&#xA;The distance between two adjacent cells is 1.&#xA;Example1 *Input*: mat = [[0,0,0],[0,1,0],[0,0,0]] *Output*: [[0,0,0],[0,1,0],[0,0,0]] Example2 *Input*: mat = [[0,0,0],[0,1,0],[1,1,1]] *Output*: [[0,0,0],[0,1,0],[1,2,1]] SOLVING we&amp;rsquo;ll use Breadth-first Search method&#xA;Steps Create matrix result with the same size filled by 0 Create a queue Parcor the list if there is a 1 next to a 0 : Add in result 1 at it&amp;rsquo;s position (because it&amp;rsquo;s at one cell from a zero) And push to the queue it&amp;rsquo;s position While queue not empty: Pop the queu to get the current value Check the neighboors (up, down, right, left) If it&amp;rsquo;s equal to 1 and equal to 0 in result (That means we didn&amp;rsquo;t see this cell before): Push to the queue it&amp;rsquo;s position Add in result the parent value in result + 1 Return result Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; updateMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;mat) { m = mat.</description>
    </item>
    <item>
      <title>Max Area Of Island Array</title>
      <link>https://example.org/posts/20230329194332-max_area_of_island_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230329194332-max_area_of_island_array/</guid>
      <description>PROBLEM You are given an m x n binary matrix grid. An island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.&#xA;The area of an island is the number of cells with a value 1 in the island.&#xA;Return the maximum area of an island in grid. If there is no island, return 0.</description>
    </item>
    <item>
      <title>Merge Two Binary Trees</title>
      <link>https://example.org/posts/20230330131636-merge_two_binary_trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230330131636-merge_two_binary_trees/</guid>
      <description>PROBLEM You are given two binary trees root1 and root2.&#xA;Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</description>
    </item>
    <item>
      <title>Minimum Path Sum</title>
      <link>https://example.org/posts/20230327124138-minimum_path_sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230327124138-minimum_path_sum/</guid>
      <description>PROBLEM Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.&#xA;Note: You can only move either down or right at any point in time.&#xA;Example *Input*: grid = [[1,3,1],[1,5,1],[4,2,1]] *Output*: 7 Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum. Constraints m==grid.length n==grid[i].length 1&amp;lt;=m, n&amp;lt;=200 0&amp;lt;=grid[i][j]&amp;lt;=100 SOLUTION We&amp;rsquo;ll use Dynamic Programming method.</description>
    </item>
    <item>
      <title>Minimum Penalty for a Shop</title>
      <link>https://example.org/posts/20230409130224-minimum_penalty_for_a_shop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230409130224-minimum_penalty_for_a_shop/</guid>
      <description>PROBLEM You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters &#39;N&#39; and &#39;Y&#39;:&#xA;if the ith character is &#39;Y&#39; , it means that customers come at the ith hour whereas &#39;N&#39; indicates that no customers come at the ith hour. If the shop closes at the jth hour (0&amp;lt;=j&amp;lt;=n), the penalty is calculated as follows:&#xA;For every hour when the shop is open and no customers come, the penalty increases by 1.</description>
    </item>
    <item>
      <title>Minimum Time To Type Using Special Typewritter</title>
      <link>https://example.org/posts/20230328225116-minimum_time_to_type_using_special_typewritter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230328225116-minimum_time_to_type_using_special_typewritter/</guid>
      <description>PROBLEM There is a special typewriter with lowercase English letters &#39;a&#39; to &#39;z&#39; arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character &#39;a&#39;.&#xA;Each second, you may perform one of the following operations:&#xA;Move the Pointer one character counterclockwise or clockwise Type the character the pointer is currently only Given a string word, return the minimum number of seconds to type out the characters in word.</description>
    </item>
    <item>
      <title>Move Zeroes</title>
      <link>https://example.org/posts/20230325150824-move_zeroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230325150824-move_zeroes/</guid>
      <description>PROBLEM Given an integer array nums, move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.&#xA;Note that you must do this in-place without making a copy of the array.&#xA;Example1 *Input*: nums = [0,1,0,3,12] *Output*: [1,3,12,0,0] Example2 *Input*: nums = [0] *Output*: [0] Constraints 1&amp;lt;=nums.length&amp;lt;=104 -231&amp;lt;=nums[i]&amp;lt;=231-1 Follow up: Could you minimize the total number of operations done?&#xA;SOLVING We&amp;rsquo;ll use the Two Pointers method</description>
    </item>
    <item>
      <title>Palindrome Number</title>
      <link>https://example.org/posts/20230413152606-palindrome_number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230413152606-palindrome_number/</guid>
      <description>PROBLEM Given an integer x, return true if x is a palindrome, and false otherwise.&#xA;Example1 *Input*: x = 121 *Output*: true *Explanation*: 121 reads as 121 from left to right and from right to left. Example2 *Input*: x = -121 *Output*: false *Explanation*: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example3 *Input*: x = 10 *Output*: false *Explanation*: Reads 01 from right to left.</description>
    </item>
    <item>
      <title>Permutation</title>
      <link>https://example.org/posts/20230403130528-permutation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230403130528-permutation/</guid>
      <description>PROBLEM Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.&#xA;Example1 *Input*: nums = [1,2,3] *Output*: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example2 *Input*: nums = [0,1] *Output*: [[0,1],[1,0]] Example3 *Input*: nums = [1] *Output*: [ [1] ] Constraints 1&amp;lt;=nums.length&amp;lt;=6 -10&amp;lt;=nums[i]&amp;lt;=10 All the integers of nums are unique. SOLVING we&amp;rsquo;ll use Backtracking method&#xA;Steps Backtracking method: push in result and return if current index equal size for each index between current index and size: swap in nums the element at current index and index from for loop call in recursive the backtrack method with as parameter current index + 1 re swap in nums the element at current index and index from for loop to reset the change return result Code class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt; &amp;amp;nums) { backtrack(nums, 0, nums.</description>
    </item>
    <item>
      <title>Populating Next Right Pointers In Each Node</title>
      <link>https://example.org/posts/20230330154600-populating_next_right_pointers_in_each_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230330154600-populating_next_right_pointers_in_each_node/</guid>
      <description>PROBLEM You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:&#xA;struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.&#xA;Initially, all next pointers are set to NULL.</description>
    </item>
    <item>
      <title>Problem Solving</title>
      <link>https://example.org/posts/20230323194445-problem_solving/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230323194445-problem_solving/</guid>
      <description>Problem solving is the process of identifying and then implementing a solution to a problem.</description>
    </item>
    <item>
      <title>Product of Array Except Self</title>
      <link>https://example.org/posts/20230528143513-product_of_array_except_self/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230528143513-product_of_array_except_self/</guid>
      <description>PROBLEM Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&#xA;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&#xA;You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1 **Input**: nums = [1,2,3,4] **Output**: [24,12,8,6] Example 2 **Input**: nums = [-1,1,0,-3,3] **Output**: [0,0,9,0,0] SOLVING We are going to make to iteration.</description>
    </item>
    <item>
      <title>Regex</title>
      <link>https://example.org/posts/20230416160653-regex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230416160653-regex/</guid>
      <description>REGULAR EXPRESSION (REGEX) In Computer Science a regular expression or rational expression or normal expression or pattern is a string which describes, according to a precise syntax, a set of possible character strings. Regular expressions are also called regex.</description>
    </item>
    <item>
      <title>Remove Duplicates from Sorted List II</title>
      <link>https://example.org/posts/20230430154252-remove_duplicates_from_sorted_list_ii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230430154252-remove_duplicates_from_sorted_list_ii/</guid>
      <description>PROBLEM Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.&#xA;Example1 *Input*: head = [1,2,3,3,4,4,5] *Output*: [1,2,5] SOLVING We&amp;rsquo;ll use Two Pointers method to solve this problem&#xA;Steps Create a Node dummy with val (0 for this example) pointing to head Create a Node prev equal to dummy Parcor the Linked List: If the current value and the next are the same: Loop until the node value is different prev-&amp;gt;next equal to this node Otherwise move prev and head of a node Return the next of dummy (previously the pointer to head) Code class Solution { public: ListNode *deleteDuplicates(ListNode *head) { ListNode *dummy = new ListNode(0, head); ListNode *prev = dummy; while (head) { if (head-&amp;gt;next &amp;amp;&amp;amp; head-&amp;gt;val == head-&amp;gt;next-&amp;gt;val) { while (head-&amp;gt;next &amp;amp;&amp;amp; head-&amp;gt;val == head-&amp;gt;next-&amp;gt;val) head = head-&amp;gt;next; prev-&amp;gt;next = head-&amp;gt;next; } else prev = prev-&amp;gt;next; head = head-&amp;gt;next; } return dummy-&amp;gt;next; } }; </description>
    </item>
    <item>
      <title>Reverse Bits</title>
      <link>https://example.org/posts/20230405204138-reverse_bits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230405204138-reverse_bits/</guid>
      <description>PROBLEM Reverse bits of a given 32 bits unsigned integer.&#xA;SOLVING We&amp;rsquo;ll use Bit Manipulation method&#xA;Steps Create a uint32_t result we&amp;rsquo;ll return as the answer Repeat 32 time or the longer of your bit result equal to result or (| or bit operation) on the result of n and (&amp;amp; and bit operation) 1 to get the first bit Example Example with 6bit (32 is tooooo long) 011101&#xA;=n= [011101] &amp;amp; 1 == 1 =result= [000000] &amp;lt;&amp;lt; 1 =n= [001110] &amp;amp; 1 == 0 =result= [000001] &amp;lt;&amp;lt; 0 =n= [000111] &amp;amp; 1 == 1 =result= [000010] &amp;lt;&amp;lt; 1 =n= [000011] &amp;amp; 1 == 1 =result= [000101] &amp;lt;&amp;lt; 1 =n= [000001] &amp;amp; 1 == 1 =result= [001011] &amp;lt;&amp;lt; 1 =n= [000000] &amp;amp; 1 == 0 =result= [010111] &amp;lt;&amp;lt; 0 =result= [101110] Code class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t result; for (int i = 0; i &amp;lt; 32; i++) { result = (result &amp;lt;&amp;lt; 1) | (n &amp;amp; 1); n &amp;gt;&amp;gt;= 1; } return result; } }; </description>
    </item>
    <item>
      <title>Reverse Linked List</title>
      <link>https://example.org/posts/20230401154745-reverse_linked_list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230401154745-reverse_linked_list/</guid>
      <description>PROBLEM Given the head of a singly linked list, reverse the list, and return the reversed list.&#xA;Example1 *Input*: head = [1,2,3,4,5] *Output*: [5,4,3,2,1] Example2 *Input*: head = [1,2] *Output*: [2,1] Example3 *Input*: head = [] *Output*: [] SOLVING Steps Create prevNode and nextNode to solve this problem nextNode equal head next N head next equal prevNode H prevNode equal head P head equal nextNode return prevNode Example1 P H N ↓ ↓ ↓ NULL [1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3 4 -&amp;gt; 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3 &amp;lt;- 4 5 -&amp;gt; NULL] head next equal prevNode head equal next P H N ↓ ↓ ↓ [NULL &amp;lt;- 1 &amp;lt;- 2 &amp;lt;- 3 &amp;lt;- 4 &amp;lt;- 5] NULL] Return prevNode Code class Solution { public: ListNode *reverseList(ListNode *head) { ListNode *nextNode = nullptr; ListNode *prevNode = nullptr; while (head) { nextNode = head-&amp;gt;next; head-&amp;gt;next = prevNode; prevNode = head; head = nextNode; } return prevNode; } }; </description>
    </item>
    <item>
      <title>Reverse Words</title>
      <link>https://example.org/posts/20230326152448-reverse_words/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230326152448-reverse_words/</guid>
      <description>PROBLEM Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.&#xA;Example1 *Input*: s = &amp;#34;Let&amp;#39;s take LeetCode contest&amp;#34; *Output*: &amp;#34;s&amp;#39;teL ekat edoCteeL tsetnoc&amp;#34; Example2 *Input*: s = &amp;#34;God Ding&amp;#34; *Output*: &amp;#34;diG gniD&amp;#34; Constraints 1&amp;lt;=s.length&amp;lt;=5*104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s. All the words in s are separated by a single space.</description>
    </item>
    <item>
      <title>Rotate Array</title>
      <link>https://example.org/posts/20230324205136-rotate_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230324205136-rotate_array/</guid>
      <description>PROBLEM Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.&#xA;Example 1 *Input*: nums = [1,2,3,4,5,6,7], k = 3 *Output*: [5,6,7,1,2,3,4] *Explanation*: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2 *Input*: nums = [-1,-100,3,99], k = 2 *Output*: [3,99,-1,-100] *Explanation*: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] SOLVING We&amp;rsquo;ll use the Two Pointers method</description>
    </item>
    <item>
      <title>Rotting Oranges</title>
      <link>https://example.org/posts/20230331192627-rotting_oranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230331192627-rotting_oranges/</guid>
      <description>PROBLEM You are given an m x n grid where each cell can have one of three values:&#xA;0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.&#xA;Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</description>
    </item>
    <item>
      <title>Search a 2D Matrix</title>
      <link>https://example.org/posts/20230430120652-search_a_2d_matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230430120652-search_a_2d_matrix/</guid>
      <description>PROBLEM You are given an m x n integer matrix matrix with the following two properties:&#xA;Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.&#xA;You must write a solution in O(log(m * n)) time complexity.&#xA;Example1 *Input*: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 *Output*: true Example2 *Input*: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 *Output*: false SOLVING we&amp;rsquo;ll use Binary Search exact value to solve this problem</description>
    </item>
    <item>
      <title>Search Insert</title>
      <link>https://example.org/posts/20230325002052-search_insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230325002052-search_insert/</guid>
      <description>PROBLEM In an sorted array [1, 3, 5, 6, 8], you want to know the index to insert your target, 5 In an sorted array [1, 3, 5, 6, 8], you want to know the index to insert your target, 2 SOLVING Use of Binary Search method.&#xA;This code will return the index 2, where the target already is This code will return the index 1 where the target should be Steps Place Left Pointer at 0 and Right Pointer to the last element Until Left Element is inferior to Right Element: Get the element between left and right Middle Index=(Left Index - RIght Index) / 2 If Middle Element equal the target, return If it&amp;rsquo;s inferior, Left Pointer becomes the Middle Pointer Otherwise it&amp;rsquo;s superior, and so Right Pointer become the Middle Pointer If the loop is finished return the Left Pointer Code #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; int searchInsert(std::vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) { int l = 0; int r = nums.</description>
    </item>
    <item>
      <title>Square Of A Sorted Array</title>
      <link>https://example.org/posts/20230324135547-square_of_a_sorted_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230324135547-square_of_a_sorted_array/</guid>
      <description>PROBLEM Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order&#xA;Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?&#xA;Example1 *Input*: nums = [-4,-1,0,3,10] *Output*: [0,1,9,16,100] *Explanation*: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2 *Input*: nums = [-7,-3,2,3,11] *Output*: [4,9,9,49,121] SOLVING We will use Two Pointers technique.</description>
    </item>
    <item>
      <title>SubRectangleQueries</title>
      <link>https://example.org/posts/20230323194502-subrectanglequeries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230323194502-subrectanglequeries/</guid>
      <description>PROBLEM Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:&#xA;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).&#xA;getValue(int row, int col) Returns the current value of the coordinate (row,col) from the rectangle.&#xA;You want to update element between row2 and row3 and between col3 and col6</description>
    </item>
    <item>
      <title>Top K Frequent Elements</title>
      <link>https://example.org/posts/20230517211447-top_k_frequent_elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230517211447-top_k_frequent_elements/</guid>
      <description>PROBLEM Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&#xA;Example 1 *Input*: nums = [1,1,1,2,2,3], k = 2 *Output*: [1,2] Example 2 *Input*: nums = [1], k = 1 *Output*: [1] SOLVING We&amp;rsquo;ll use the Bucket Sort method.&#xA;Steps Create a Map to store the frequency of each letters, a Map buckets and the array for the result Iterate on the string use each letter as key for frequency and increase by one the value Fill the buckets by using the value of frequency as the key of buckets and add the key of frequency in the value of the bucket Iterate from the end of buckets: Iterate on each element in the bucket value: Add this element to result if result length is equal to k return result Example With the parameters nums = [1,1,1,2,2,3] and k = 2</description>
    </item>
    <item>
      <title>Two Pointers</title>
      <link>https://example.org/posts/20230318190022-two_pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230318190022-two_pointers/</guid>
      <description>INFO The two pointers is a searching algorithm if you want at the same time:&#xA;Search two elements in an array Search and do something in an array Keep in mind an index when moving another Ect&amp;hellip; </description>
    </item>
    <item>
      <title>Two Sum || Array Sorted</title>
      <link>https://example.org/posts/20230325165639-two_sum_array_sorted/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230325165639-two_sum_array_sorted/</guid>
      <description>PROBLEM Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1&amp;lt;=index1&amp;lt;index2&amp;lt;=numbers.length.&#xA;Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.&#xA;The tests are generated such that there is exactly one solution.</description>
    </item>
    <item>
      <title>Valid Parentheses</title>
      <link>https://example.org/posts/20230410164240-valid_parentheses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230410164240-valid_parentheses/</guid>
      <description>PROBLEM Given a string s containing just the characters &#39;(&#39; , &#39;)&#39; , &#39;{&#39; , &#39;}&#39; , &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.&#xA;An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example1 *Input*: s = &amp;#34;()&amp;#34; *Output*: true Example2 *Input*: s = &amp;#34;([]){}&amp;#34; *Output*: true Example3 *Input*: s = &amp;#34;(]&amp;#34; *Output*: false SOLVING Steps Create a Stack Browse the string: If characters is an open parentheses push to the stack If characters is an close parentheses If the top of the stack is the open equivalent pop the stack Otherwise return false, the string isn&amp;rsquo;t closing the last open parentheses Otherwise return false, the character isn&amp;rsquo;t an open or close parentheses return true if the stack is empty otherwise false because all parentheses aren&amp;rsquo;t closed Code class Solution { public: bool isValid(string s) { const string open = &amp;#34;({[&amp;#34;; const string close = &amp;#34;)}]&amp;#34;; stack&amp;lt;char&amp;gt; parenthesesOpen; for (int i = 0; i &amp;lt; s.</description>
    </item>
    <item>
      <title>Valid Phone Numbers</title>
      <link>https://example.org/posts/20230416164058-valid_phone_numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.org/posts/20230416164058-valid_phone_numbers/</guid>
      <description>PROBLEM Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.&#xA;You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)&#xA;You may also assume each line in the text file must not contain leading or trailing white spaces.</description>
    </item>
  </channel>
</rss>
